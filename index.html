<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>It's Toni Time üíï</title>
    
    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/10.8.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.8.0/firebase-firestore-compat.js"></script>
    
    <!-- Cloudinary SDK -->
    <script src="https://upload-widget.cloudinary.com/global/all.js" type="text/javascript"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 20px;
            position: relative;
        }
        
        /* Mosaic background */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-image: 
                url('cats/cat1.jpg'),
                url('cats/cat2.jpg'),
                url('cats/cat3.jpg'),
                url('cats/cat4.jpg'),
                url('cats/cat5.jpg');
            background-size: 150px 150px, 200px 200px, 180px 180px, 170px 170px, 190px 190px;
            background-position: 
                10% 20%,
                80% 30%,
                20% 70%,
                90% 80%,
                50% 90%;
            background-repeat: no-repeat;
            opacity: 0.05;
            z-index: 0;
            pointer-events: none;
            filter: blur(1px);
        }
        
        .container {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 24px;
            padding: 40px;
            box-shadow: 0 30px 90px rgba(0, 0, 0, 0.5);
            max-width: 900px;
            width: 100%;
            position: relative;
            z-index: 1;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        h1 {
            text-align: center;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 10px;
            font-size: 2.5em;
            font-weight: 700;
            letter-spacing: -1px;
        }
        
        .visit-counter {
            text-align: center;
            color: #667eea;
            font-size: 0.9em;
            margin-bottom: 20px;
            font-weight: 600;
        }
        
        .mood-selector {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        
        .mood-btn {
            padding: 10px 20px;
            border: 2px solid transparent;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 25px;
            cursor: pointer;
            font-size: 0.9em;
            transition: all 0.3s;
            font-weight: 600;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
        }
        
        .mood-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.5);
        }
        
        .mood-btn.active {
            background: linear-gradient(135deg, #764ba2 0%, #667eea 100%);
            box-shadow: 0 6px 25px rgba(118, 75, 162, 0.6);
            transform: translateY(-2px);
        }
        
        .photo-container {
            position: relative;
            width: 100%;
            max-height: 600px;
            overflow: hidden;
            border-radius: 16px;
            background: #f0f0f0;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
        }
        
        #catPhoto {
            max-width: 100%;
            max-height: 600px;
            width: auto;
            height: auto;
            display: block;
            border-radius: 16px;
            transition: transform 0.3s ease;
        }
        
        .photo-container:hover #catPhoto {
            transform: scale(1.01);
        }
        
        .rating-container {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
            margin-top: 15px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 10px;
        }
        
        .rating-label {
            font-size: 0.9em;
            color: #666;
            font-weight: 600;
        }
        
        .heart {
            font-size: 2em;
            cursor: pointer;
            transition: transform 0.2s, filter 0.2s;
            user-select: none;
        }
        
        .heart:hover {
            transform: scale(1.2);
            filter: brightness(1.2);
        }
        
        .heart.filled {
            color: #ff6b6b;
        }
        
        .heart.empty {
            color: #ddd;
        }
        
        .clear-rating {
            font-size: 1.2em;
            cursor: pointer;
            color: #999;
            margin-left: 15px;
            transition: all 0.3s;
            user-select: none;
            padding: 5px 10px;
            border-radius: 5px;
        }
        
        .clear-rating:hover {
            color: #f5576c;
            background: rgba(245, 87, 108, 0.1);
            transform: scale(1.1);
        }
        
        .button-container {
            margin-top: 20px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 1.1em;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
        }
        
        button:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 30px rgba(102, 126, 234, 0.6);
        }
        
        button:active {
            transform: translateY(-1px);
        }
        
        button.secondary {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            box-shadow: 0 6px 20px rgba(245, 87, 108, 0.4);
        }
        
        button.secondary:hover {
            box-shadow: 0 10px 30px rgba(245, 87, 108, 0.6);
        }
        
        button.success {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            box-shadow: 0 6px 20px rgba(79, 172, 254, 0.4);
        }
        
        button.success:hover {
            box-shadow: 0 10px 30px rgba(79, 172, 254, 0.6);
        }
        
        .controls-row {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 15px;
            flex-wrap: wrap;
        }
        
        .control-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.9em;
            color: #666;
        }
        
        .toggle-switch {
            position: relative;
            width: 50px;
            height: 26px;
        }
        
        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 34px;
        }
        
        .slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        
        input:checked + .slider {
            background-color: #667eea;
        }
        
        input:checked + .slider:before {
            transform: translateX(24px);
        }
        
        .slideshow-status {
            text-align: center;
            color: #667eea;
            font-size: 1em;
            margin-top: 10px;
            font-weight: 600;
            min-height: 30px;
            font-variant-numeric: tabular-nums;
        }
        
        .slideshow-status.countdown {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            font-size: 1.2em;
        }
        
        /* My Favorites Section */
        .favorites-section {
            margin-top: 30px;
            padding-top: 30px;
            border-top: 2px solid #f0f0f0;
        }
        
        .favorites-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        
        .favorites-header h2 {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            font-size: 1.8em;
            font-weight: 700;
        }
        
        .filter-buttons {
            display: flex;
            gap: 10px;
        }
        
        .filter-btn {
            padding: 8px 16px;
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
            border: none;
            border-radius: 20px;
            cursor: pointer;
            font-size: 0.85em;
            font-weight: 600;
            transition: all 0.3s;
            box-shadow: 0 4px 15px rgba(240, 147, 251, 0.3);
        }
        
        .filter-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(240, 147, 251, 0.5);
        }
        
        .filter-btn.active {
            background: linear-gradient(135deg, #764ba2 0%, #f5576c 100%);
        }
        
        .favorites-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }
        
        .favorite-item {
            position: relative;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.15);
            transition: transform 0.3s, box-shadow 0.3s;
            cursor: pointer;
            background: #f8f9fa;
        }
        
        .favorite-item:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.25);
        }
        
        .favorite-item img {
            width: 100%;
            height: 200px;
            object-fit: cover;
            display: block;
        }
        
        .favorite-rating {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(5px);
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 0.9em;
            font-weight: 600;
            color: #ff6b6b;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
        }
        
        .favorite-actions {
            padding: 12px;
            background: white;
            display: flex;
            gap: 10px;
        }
        
        .favorite-actions button {
            flex: 1;
            padding: 8px 16px;
            font-size: 0.85em;
        }
        
        .edit-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
        
        .no-favorites {
            text-align: center;
            padding: 40px;
            color: #999;
            font-size: 1.1em;
        }
        
        .no-favorites-icon {
            font-size: 3em;
            margin-bottom: 15px;
        }
        
        /* Upload Section */
        .upload-section {
            margin-top: 30px;
            padding: 30px;
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.1) 0%, rgba(118, 75, 162, 0.1) 100%);
            border-radius: 16px;
            border: 2px dashed rgba(102, 126, 234, 0.3);
        }
        
        .upload-section h2 {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            font-size: 1.8em;
            font-weight: 700;
            margin-bottom: 20px;
            text-align: center;
        }
        
        .upload-area {
            text-align: center;
            padding: 40px;
            background: white;
            border-radius: 12px;
            border: 2px dashed #667eea;
            transition: all 0.3s;
            cursor: pointer;
        }
        
        .upload-area:hover {
            border-color: #764ba2;
            background: #f8f9fa;
            transform: translateY(-2px);
        }
        
        .upload-area.drag-over {
            border-color: #764ba2;
            background: #f0f4ff;
            transform: scale(1.02);
        }
        
        .upload-icon {
            font-size: 3em;
            margin-bottom: 15px;
        }
        
        .upload-text {
            font-size: 1.1em;
            color: #666;
            margin-bottom: 10px;
        }
        
        .upload-hint {
            font-size: 0.9em;
            color: #999;
        }
        
        #fileInput {
            display: none;
        }
        
        /* Batch Upload Preview */
        .batch-preview {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }
        
        .batch-item {
            position: relative;
            border-radius: 8px;
            overflow: hidden;
            background: white;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
            cursor: pointer;
            transition: all 0.3s;
            border: 3px solid transparent;
        }
        
        .batch-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.15);
        }
        
        .batch-item.selected {
            border-color: #667eea;
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
            transform: scale(1.02);
        }
        
        .batch-item.selected::after {
            content: '‚úì';
            position: absolute;
            top: 10px;
            left: 10px;
            background: #667eea;
            color: white;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 1.2em;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            z-index: 10;
        }
        
        .batch-item img {
            width: 100%;
            height: 150px;
            object-fit: cover;
        }
        
        .batch-item-moods {
            padding: 8px;
            font-size: 0.75em;
            min-height: 40px;
        }
        
        .batch-item-actions {
            padding: 8px;
            display: flex;
            gap: 5px;
            justify-content: space-between;
        }
        
        .batch-item-actions button {
            padding: 6px 12px;
            font-size: 0.8em;
        }
        
        .remove-batch-item {
            position: absolute;
            top: 5px;
            right: 5px;
            background: rgba(245, 87, 108, 0.9);
            color: white;
            border: none;
            width: 25px;
            height: 25px;
            border-radius: 50%;
            cursor: pointer;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s;
        }
        
        .remove-batch-item:hover {
            background: #f5576c;
            transform: scale(1.1);
        }
        
        /* Edit Tags Modal */
        .edit-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            backdrop-filter: blur(5px);
        }
        
        .edit-modal-content {
            background: white;
            padding: 30px;
            border-radius: 16px;
            max-width: 500px;
            width: 90%;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
        }
        
        .edit-modal-content h3 {
            margin-bottom: 20px;
            color: #667eea;
        }
        
        .edit-preview-img {
            width: 100%;
            max-height: 200px;
            object-fit: contain;
            border-radius: 8px;
            margin-bottom: 20px;
        }
        
        .favorite-actions button {
            flex: 1;
            padding: 8px 16px;
            font-size: 0.85em;
        }
        
        .edit-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }
        
        .mood-tags {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-top: 20px;
            flex-wrap: wrap;
        }
        
        .mood-tag {
            padding: 8px 16px;
            background: white;
            border: 2px solid #667eea;
            color: #667eea;
            border-radius: 20px;
            cursor: pointer;
            font-size: 0.9em;
            font-weight: 600;
            transition: all 0.3s;
        }
        
        .mood-tag:hover {
            background: #667eea;
            color: white;
        }
        
        .mood-tag.selected {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-color: #764ba2;
        }
        
        .upload-preview {
            margin-top: 20px;
            display: none;
        }
        
        .upload-preview.show {
            display: block;
        }
        
        .preview-image {
            max-width: 300px;
            max-height: 300px;
            border-radius: 12px;
            margin: 20px auto;
            display: block;
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.15);
        }
        
        .upload-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 20px;
        }
        
        .upload-progress {
            margin-top: 20px;
            display: none;
        }
        
        .upload-progress.show {
            display: block;
        }
        
        .progress-bar {
            width: 100%;
            height: 30px;
            background: #f0f0f0;
            border-radius: 15px;
            overflow: hidden;
            margin-top: 10px;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            transition: width 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 600;
        }
        
        .loading {
            text-align: center;
            color: #666;
            font-style: italic;
        }

        /* Username Modal */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            backdrop-filter: blur(5px);
        }
        
        .modal-content {
            background: white;
            padding: 40px;
            border-radius: 20px;
            max-width: 400px;
            width: 90%;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            text-align: center;
        }
        
        .modal-content h2 {
            color: #667eea;
            margin-bottom: 15px;
            font-size: 1.8em;
        }
        
        .modal-content p {
            color: #666;
            margin-bottom: 25px;
            line-height: 1.6;
        }
        
        .username-input {
            width: 100%;
            padding: 15px;
            border: 2px solid #ddd;
            border-radius: 10px;
            font-size: 1.1em;
            margin-bottom: 20px;
            transition: border-color 0.3s;
        }
        
        .username-input:focus {
            outline: none;
            border-color: #667eea;
        }
        
        .modal-button {
            width: 100%;
            padding: 15px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 50px;
            font-size: 1.1em;
            cursor: pointer;
            font-weight: 600;
            transition: transform 0.2s;
        }
        
        .modal-button:hover {
            transform: translateY(-2px);
        }
        
        .modal-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .user-info {
            text-align: center;
            color: #764ba2;
            font-size: 0.85em;
            margin-bottom: 10px;
            font-weight: 600;
        }
        
        .user-info .change-user {
            color: #667eea;
            text-decoration: underline;
            cursor: pointer;
            margin-left: 10px;
        }
        
        .error-message {
            color: #f5576c;
            font-size: 0.9em;
            margin-top: 10px;
            min-height: 20px;
        }
        
        .hidden {
            display: none !important;
        }
        
        /* Collage Generator Styles */
        .collage-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            z-index: 10000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }
        
        .collage-controls {
            background: white;
            padding: 20px;
            border-radius: 15px;
            margin-bottom: 20px;
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        }
        
        .collage-controls button {
            padding: 10px 20px;
            font-size: 0.9em;
        }
        
        .collage-controls select {
            padding: 10px;
            border: 2px solid #667eea;
            border-radius: 8px;
            font-size: 1em;
            background: white;
            cursor: pointer;
        }
        
        .collage-container {
            background: white;
            padding: 20px;
            border-radius: 15px;
            max-width: 90vw;
            max-height: 70vh;
            overflow: auto;
            box-shadow: 0 8px 30px rgba(0,0,0,0.5);
        }
        
        .collage-canvas-wrapper {
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        #collageCanvas {
            max-width: 100%;
            height: auto;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }

        @media (max-width: 600px) {
            h1 {
                font-size: 1.5em;
            }
            
            .container {
                padding: 20px;
            }
            
            button {
                font-size: 0.9em;
                padding: 12px 20px;
            }
            
            .mood-btn {
                font-size: 0.8em;
                padding: 6px 12px;
            }
            
            .heart {
                font-size: 1.5em;
            }
            
            .modal-content {
                padding: 30px 20px;
            }
            
            .collage-controls {
                flex-direction: column;
                width: 100%;
            }
            
            .collage-controls button,
            .collage-controls select {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <!-- Username Modal -->
    <div id="usernameModal" class="modal-overlay hidden">
        <div class="modal-content">
            <h2>Welcome! üíï</h2>
            <p>Enter the secret code and your username to access Toni's gallery!</p>
            <div style="position: relative;">
                <input 
                    type="password" 
                    id="secretCodeInput" 
                    class="username-input" 
                    placeholder="Secret code..."
                    maxlength="50"
                    style="padding-right: 45px;"
                />
                <button 
                    id="toggleSecretCode" 
                    onclick="toggleSecretCodeVisibility()"
                    style="position: absolute; right: 10px; top: 50%; transform: translateY(-50%); background: none; border: none; cursor: pointer; font-size: 1.2em; padding: 5px 10px;"
                    title="Show/hide secret code"
                >
                    üëÅÔ∏è
                </button>
            </div>
            <input 
                type="text" 
                id="usernameInput" 
                class="username-input" 
                placeholder="Enter username..."
                maxlength="20"
            />
            <div class="error-message" id="errorMessage"></div>
            <button class="modal-button" onclick="saveUsername()">Get Started</button>
        </div>
    </div>

    <div class="container">
        <div class="user-info" id="userInfo"></div>
        <h1>It's Toni Time</h1>
        <div class="visit-counter" id="visitCounter">Loading...</div>
        
        <div class="mood-selector">
            <button class="mood-btn active" data-mood="all" onclick="selectMood('all')">‚ú® All Moods</button>
            <button class="mood-btn" data-mood="unbridled_rage" onclick="selectMood('unbridled_rage')">üò§ Unbridled Rage</button>
            <button class="mood-btn" data-mood="lazy_boy" onclick="selectMood('lazy_boy')">üò¥ Lazy Boy</button>
            <button class="mood-btn" data-mood="sweet_perfect_angel_cat" onclick="selectMood('sweet_perfect_angel_cat')">üòá Sweet Perfect Angel Cat</button>
            <button class="mood-btn" data-mood="weirdo" onclick="selectMood('weirdo')">ü§™ Weirdo</button>
            <button class="mood-btn" data-mood="someone_help" onclick="selectMood('someone_help')">üÜò Someone Help</button>
        </div>
        
        <div class="photo-container" id="photoContainer">
            <img id="catPhoto" alt="A cute cat" />
        </div>
        
        <div id="uploaderInfo" style="text-align: center; margin: 10px 0; font-size: 0.9em; color: #666; opacity: 0; transition: opacity 0.3s;">
            üì∏ Uploaded by <span id="uploaderName" style="font-weight: 600; color: #667eea;"></span>
        </div>
        
        <div class="rating-container">
            <span class="rating-label">Rate this photo:</span>
            <span class="heart empty" data-rating="1" onclick="ratePhoto(1)">‚ô•</span>
            <span class="heart empty" data-rating="2" onclick="ratePhoto(2)">‚ô•</span>
            <span class="heart empty" data-rating="3" onclick="ratePhoto(3)">‚ô•</span>
            <span class="heart empty" data-rating="4" onclick="ratePhoto(4)">‚ô•</span>
            <span class="heart empty" data-rating="5" onclick="ratePhoto(5)">‚ô•</span>
            <span class="clear-rating" onclick="clearRating()" title="Clear rating">‚úñ</span>
        </div>
        
        <div class="button-container">
            <button onclick="loadRandomPhoto()">üêæ Next Toni</button>
            <button class="secondary" onclick="downloadPhoto()">üíæ Download</button>
            <button class="secondary" onclick="window.open('instagram.html', '_blank')" title="View Toni's fake Instagram feed">üì± Tonstergram</button>
            <button class="secondary" onclick="openCollageGenerator()" title="Generate a collage of random Toni photos">üé® Make Collage</button>
        </div>
        
        <div class="controls-row">
            <div class="control-item">
                <span>üîä Sound:</span>
                <label class="toggle-switch">
                    <input type="checkbox" id="soundToggle" checked onchange="toggleSound()">
                    <span class="slider"></span>
                </label>
            </div>
            <div class="control-item">
                <span>üé¨ Slideshow:</span>
                <label class="toggle-switch">
                    <input type="checkbox" id="slideshowToggle" onchange="toggleSlideshow()">
                    <span class="slider"></span>
                </label>
            </div>
        </div>
        
        <div class="slideshow-status" id="slideshowStatus"></div>
        
        <!-- My Favorites Section -->
        <div class="favorites-section" id="favoritesSection">
            <div class="favorites-header">
                <h2>üíï My Favorites</h2>
                <div class="filter-buttons">
                    <button class="filter-btn active" onclick="filterFavorites('all')">All</button>
                    <button class="filter-btn" onclick="filterFavorites(5)">5 ‚ô•</button>
                    <button class="filter-btn" onclick="filterFavorites(4)">4+ ‚ô•</button>
                </div>
            </div>
            <div class="favorites-grid" id="favoritesGrid">
                <!-- Favorites will be populated here -->
            </div>
        </div>
        
        <!-- Collage Generator Modal -->
        <div id="collageModal" class="collage-modal hidden">
            <div class="collage-controls">
                <label>
                    Layout:
                    <select id="collageLayout" onchange="generateCollage()">
                        <option value="2x2">2√ó2 Grid (4 photos)</option>
                        <option value="3x3" selected>3√ó3 Grid (9 photos)</option>
                        <option value="4x4">4√ó4 Grid (16 photos)</option>
                        <option value="mosaic">Random Mosaic</option>
                    </select>
                </label>
                <button onclick="generateCollage()">üîÑ Regenerate</button>
                <button onclick="downloadCollage()">üíæ Download</button>
                <button class="secondary" onclick="closeCollageGenerator()">‚úñ Close</button>
            </div>
            <div class="collage-container">
                <div class="collage-canvas-wrapper">
                    <canvas id="collageCanvas"></canvas>
                </div>
            </div>
        </div>
        
        <!-- Upload Section -->
        <div class="upload-section" id="uploadSection">
            <h2>üì∏ Upload New Photo</h2>
            
            <div class="upload-area" id="uploadArea" onclick="document.getElementById('fileInput').click()">
                <div class="upload-icon">üê±üì∑</div>
                <div class="upload-text">Click to upload or drag and drop</div>
                <div class="upload-hint">JPG, JPEG, PNG up to 10MB ‚Ä¢ Multiple files supported</div>
                <input type="file" id="fileInput" accept="image/jpeg,image/jpg,image/png" multiple />
            </div>
            
            <div id="batchPreview" class="batch-preview"></div>
            
            <div id="batchTagSection" class="hidden" style="margin: 30px auto; max-width: 600px; padding: 25px; background: white; border-radius: 16px; box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);">
                <h3 style="text-align: center; color: #667eea; margin-bottom: 20px;">üè∑Ô∏è Batch Tag Selected Photos</h3>
                <p style="text-align: center; color: #666; margin-bottom: 15px; font-size: 0.9em;">
                    <span id="selectedCount" style="font-weight: 600; color: #667eea;">0 photos selected</span><br>
                    üí° <strong>Click</strong> photos to select ‚Ä¢ <strong>Ctrl/Cmd+Click</strong> for multiple ‚Ä¢ <strong>Select All</strong> button below
                </p>
                <div style="display: flex; gap: 10px; margin-bottom: 15px; justify-content: center;">
                    <button class="secondary" onclick="selectAllBatchItems()" style="padding: 8px 20px;">‚úì Select All</button>
                    <button class="secondary" onclick="deselectAllBatchItems()" style="padding: 8px 20px;">‚úï Deselect All</button>
                </div>
                <div class="mood-tags" id="batchAllMoodTags" style="margin-bottom: 20px;">
                    <div class="mood-tag" data-mood="unbridled_rage" onclick="toggleBatchAllMood('unbridled_rage')">üò§ Unbridled Rage</div>
                    <div class="mood-tag" data-mood="lazy_boy" onclick="toggleBatchAllMood('lazy_boy')">üò¥ Lazy Boy</div>
                    <div class="mood-tag" data-mood="sweet_perfect_angel_cat" onclick="toggleBatchAllMood('sweet_perfect_angel_cat')">üòá Sweet Perfect Angel Cat</div>
                    <div class="mood-tag" data-mood="weirdo" onclick="toggleBatchAllMood('weirdo')">ü§™ Weirdo</div>
                    <div class="mood-tag" data-mood="someone_help" onclick="toggleBatchAllMood('someone_help')">üÜò Someone Help</div>
                </div>
                <div style="display: flex; gap: 10px;">
                    <button class="success" style="flex: 1;" onclick="applyBatchTagsToSelected()">‚úÖ Apply to Selected</button>
                    <button class="secondary" style="flex: 1;" onclick="clearSelectedTags()">üóëÔ∏è Clear Selected Tags</button>
                </div>
                <p style="text-align: center; color: #999; margin-top: 15px; font-size: 0.85em;">
                    üí° You can still edit individual photo tags by clicking "üè∑Ô∏è Tag" on each photo
                </p>
            </div>
            
            <div class="upload-preview" id="uploadPreview">
                <img id="previewImage" class="preview-image" alt="Preview" />
                
                <div class="mood-tags-label" style="text-align: center; margin-top: 20px; font-weight: 600; color: #667eea;">
                    Select Moods (click multiple):
                </div>
                <div class="mood-tags" id="moodTags">
                    <div class="mood-tag" data-mood="unbridled_rage" onclick="toggleMoodTag('unbridled_rage')">üò§ Unbridled Rage</div>
                    <div class="mood-tag" data-mood="lazy_boy" onclick="toggleMoodTag('lazy_boy')">üò¥ Lazy Boy</div>
                    <div class="mood-tag" data-mood="sweet_perfect_angel_cat" onclick="toggleMoodTag('sweet_perfect_angel_cat')">üòá Sweet Perfect Angel Cat</div>
                    <div class="mood-tag" data-mood="weirdo" onclick="toggleMoodTag('weirdo')">ü§™ Weirdo</div>
                    <div class="mood-tag" data-mood="someone_help" onclick="toggleMoodTag('someone_help')">üÜò Someone Help</div>
                </div>
                
                <div class="upload-buttons">
                    <button class="success" onclick="uploadPhoto()">‚úÖ Upload Photo</button>
                    <button class="secondary" onclick="cancelUpload()">‚ùå Cancel</button>
                </div>
            </div>
            
            <div class="upload-progress" id="uploadProgress">
                <div style="text-align: center; color: #667eea; font-weight: 600; margin-bottom: 10px;">
                    Uploading...
                </div>
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill" style="width: 0%">0%</div>
                </div>
            </div>
        </div>
    </div>

    <!-- Audio element for meow sound -->
    <audio id="meowSound" preload="auto">
        <!-- Using a data URI for a simple beep sound since we can't guarantee external audio files -->
        <!-- You can replace this with an actual meow.mp3 file if you have one -->
    </audio>

    <script>
        // Cloudinary Configuration
        // REPLACE WITH YOUR CLOUDINARY CREDENTIALS
        const cloudinaryConfig = {
            cloudName: 'dhjs7c8ix',
            uploadPreset: 'toni_gallery_upload',
            folder: 'toni-gallery',
            uploadUrl: 'https://api.cloudinary.com/v1_1/dhjs7c8ix/image/upload'
        };

        const firebaseConfig = {
  apiKey: "AIzaSyCdZpJL_uuutN-ucfaa_nZtuVAOII2csCg",
  authDomain: "toni-pet.firebaseapp.com",
  projectId: "toni-pet",
  storageBucket: "toni-pet.firebasestorage.app",
  messagingSenderId: "622524049665",
  appId: "1:622524049665:web:517998a212f53219845300",
  measurementId: "G-SHHD192VFD"
};

        // Initialize Firebase
        let db = null;
        let firebaseEnabled = false;
        
        try {
            if (firebaseConfig.apiKey !== "YOUR_API_KEY") {
                firebase.initializeApp(firebaseConfig);
                db = firebase.firestore();
                firebaseEnabled = true;
                console.log("Firebase initialized successfully!");
            } else {
                console.log("Firebase not configured - using localStorage only");
            }
        } catch (error) {
            console.log("Firebase initialization failed - using localStorage only", error);
        }

        // Photo configuration with moods
        // Photos will be loaded from:
        // 1. Cloudinary uploads (via localStorage/Firestore)
        // 2. Any manually added photos below
        const catPhotos = [
            // Add your initial photos here with their mood tags
            // Example: { path: 'https://res.cloudinary.com/your-cloud/image/upload/v1234567890/toni-gallery/photo.jpg', moods: ['unbridled_rage'] },
            
            // These will be populated from uploads automatically
        ];

        // State management
        let currentPhoto = null;
        let currentMood = 'all';
        let soundEnabled = true;
        let slideshowInterval = null;
        let slideshowCountdown = null;
        let slideshowTimeLeft = 5;
        let visitCount = 0;
        let currentUser = null;
        let currentFavoriteFilter = 'all';
        
        // Upload state
        let selectedFile = null;
        let selectedMoods = [];
        let batchFiles = []; // For batch upload
        let batchAllMoods = []; // For batch tagging all photos
        let selectedBatchItems = []; // For multi-select batch tagging
        
        // Purr functionality state
        let purrProgress = 0;
        let purrThreshold = 1.5; // seconds of rubbing needed
        let isPurring = false;
        let lastMouseMove = 0;
        let purrAudio = null;
        
        // Initialize on page load
        window.addEventListener('load', async function() {
            console.log('üöÄ Page loaded, initializing...');
            await checkUsername();
            initializeUpload(); // Initialize upload functionality
            await loadPhotosFromFirestore(); // Load shared photos from Firestore with real-time sync
            initializeVisitCounter();
            // loadRandomPhoto() is called by loadPhotosFromFirestore() after photos are loaded
            initializeMeowSound();
            initializePurrFeature();
            loadFavorites();
            console.log('‚úÖ Initialization complete!');
        });
        
        // Username Management with Secret Code Protection
        async function checkUsername() {
            const savedUsername = localStorage.getItem('toniUsername');
            const hasAccess = localStorage.getItem('toniAccess') === 'granted';
            
            if (savedUsername && hasAccess) {
                currentUser = savedUsername;
                updateUserInfo();
                if (firebaseEnabled) {
                    await loadRatingsFromFirebase();
                }
            } else {
                // Clear any partial data if access wasn't granted
                if (!hasAccess) {
                    localStorage.removeItem('toniUsername');
                }
                showUsernameModal();
            }
        }
        
        function showUsernameModal() {
            document.getElementById('usernameModal').classList.remove('hidden');
            document.getElementById('secretCodeInput').focus();
        }
        
        function toggleSecretCodeVisibility() {
            const secretCodeInput = document.getElementById('secretCodeInput');
            const toggleBtn = document.getElementById('toggleSecretCode');
            
            if (secretCodeInput.type === 'password') {
                secretCodeInput.type = 'text';
                toggleBtn.textContent = 'üôà'; // Hide icon
                toggleBtn.title = 'Hide secret code';
            } else {
                secretCodeInput.type = 'password';
                toggleBtn.textContent = 'üëÅÔ∏è'; // Show icon
                toggleBtn.title = 'Show secret code';
            }
        }
        
        function hideUsernameModal() {
            document.getElementById('usernameModal').classList.add('hidden');
        }
        
        async function saveUsername() {
            const secretCodeInput = document.getElementById('secretCodeInput');
            const usernameInput = document.getElementById('usernameInput');
            const secretCode = secretCodeInput.value.trim();
            const username = usernameInput.value.trim();
            const errorMsg = document.getElementById('errorMessage');
            
            // Validate secret code first
            if (!secretCode) {
                errorMsg.textContent = 'Please enter the secret code';
                secretCodeInput.focus();
                return;
            }
            
            if (secretCode !== 'toni_bologna') {
                errorMsg.textContent = '‚ùå Incorrect secret code. Try again!';
                secretCodeInput.value = '';
                secretCodeInput.focus();
                return;
            }
            
            // Validate username
            if (!username) {
                errorMsg.textContent = 'Please enter a username';
                usernameInput.focus();
                return;
            }
            
            if (username.length < 2) {
                errorMsg.textContent = 'Username must be at least 2 characters';
                usernameInput.focus();
                return;
            }
            
            // Sanitize username (alphanumeric, spaces, hyphens, underscores only)
            const sanitized = username.replace(/[^a-zA-Z0-9\s_-]/g, '');
            if (sanitized !== username) {
                errorMsg.textContent = 'Username can only contain letters, numbers, spaces, - and _';
                usernameInput.focus();
                return;
            }
            
            // Grant access
            currentUser = username;
            localStorage.setItem('toniUsername', username);
            localStorage.setItem('toniAccess', 'granted');
            
            // Load ratings from Firebase if available
            if (firebaseEnabled) {
                await loadRatingsFromFirebase();
            }
            
            updateUserInfo();
            hideUsernameModal();
            
            // Reload current photo to show correct rating
            if (currentPhoto) {
                const savedRating = getRating(currentPhoto.path);
                updateRatingDisplay(savedRating);
            }
            
            // Load favorites
            loadFavorites();
        }
        
        function updateUserInfo() {
            const userInfoElement = document.getElementById('userInfo');
            if (currentUser) {
                userInfoElement.innerHTML = `Logged in as: <strong>${currentUser}</strong> <span class="change-user" onclick="changeUser()">Change User</span>`;
            } else {
                userInfoElement.textContent = '';
            }
        }
        
        function changeUser() {
            if (confirm('Switch users? Your current ratings will be saved.')) {
                localStorage.removeItem('toniUsername');
                localStorage.removeItem('toniAccess'); // Clear access
                currentUser = null;
                showUsernameModal();
            }
        }
        
        // Allow Enter key in modal inputs
        document.addEventListener('DOMContentLoaded', function() {
            const secretCodeInput = document.getElementById('secretCodeInput');
            const usernameInput = document.getElementById('usernameInput');
            
            if (secretCodeInput) {
                secretCodeInput.addEventListener('keypress', function(e) {
                    if (e.key === 'Enter') {
                        // Move to username field if secret code is entered
                        if (secretCodeInput.value.trim()) {
                            usernameInput.focus();
                        }
                    }
                });
            }
            
            if (usernameInput) {
                usernameInput.addEventListener('keypress', function(e) {
                    if (e.key === 'Enter') {
                        saveUsername();
                    }
                });
            }
        });
        
        // Visit counter (per user)
        function initializeVisitCounter() {
            if (!currentUser) {
                visitCount = 0;
                return;
            }
            
            const key = `toniVisitCount_${currentUser}`;
            visitCount = parseInt(localStorage.getItem(key) || '0');
            visitCount++;
            localStorage.setItem(key, visitCount.toString());
            updateVisitCounter();
        }
        
        function updateVisitCounter() {
            const counter = document.getElementById('visitCounter');
            if (currentUser) {
                const times = visitCount === 1 ? 'time' : 'times';
                counter.textContent = `You've smiled at Toni ${visitCount} ${times}! üíï`;
            } else {
                counter.textContent = '';
            }
        }
        
        // Mood selector
        function selectMood(mood) {
            currentMood = mood;
            
            // Update button states
            document.querySelectorAll('.mood-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            document.querySelector(`[data-mood="${mood}"]`).classList.add('active');
            
            loadRandomPhoto();
        }
        
        // Get photos filtered by mood
        function getFilteredPhotos() {
            if (currentMood === 'all') {
                return catPhotos;
            }
            return catPhotos.filter(photo => photo.moods.includes(currentMood));
        }
        
        // Load random photo with validation
        async function loadRandomPhoto() {
            const filteredPhotos = getFilteredPhotos();
            
            if (filteredPhotos.length === 0) {
                document.getElementById('catPhoto').alt = 'No photos available for this mood!';
                document.getElementById('catPhoto').src = '';
                currentPhoto = null;
                updateRatingDisplay(0);
                return;
            }
            
            // Try to find a valid photo (max 3 attempts)
            let attempts = 0;
            let validPhoto = null;
            
            while (attempts < 3 && !validPhoto) {
                const randomIndex = Math.floor(Math.random() * filteredPhotos.length);
                const photo = filteredPhotos[randomIndex];
                
                // Check if image loads
                const exists = await checkImageExists(photo.path);
                if (exists) {
                    validPhoto = photo;
                } else {
                    console.log('Skipping broken image:', photo.path);
                    // Remove from catPhotos array
                    const index = catPhotos.findIndex(p => p.path === photo.path);
                    if (index > -1) {
                        catPhotos.splice(index, 1);
                    }
                }
                attempts++;
            }
            
            if (!validPhoto) {
                document.getElementById('catPhoto').alt = 'No valid photos available. Please upload some photos!';
                document.getElementById('catPhoto').src = '';
                currentPhoto = null;
                updateRatingDisplay(0);
                return;
            }
            
            currentPhoto = validPhoto;
            
            const imgElement = document.getElementById('catPhoto');
            imgElement.src = currentPhoto.path;
            imgElement.alt = 'A cute cat photo';
            
            // Handle load error
            imgElement.onerror = function() {
                console.log('Image failed to load:', currentPhoto.path);
                // Remove from array and try again
                const index = catPhotos.findIndex(p => p.path === currentPhoto.path);
                if (index > -1) {
                    catPhotos.splice(index, 1);
                }
                loadRandomPhoto(); // Try loading another photo
            };
            
            // Load saved rating
            const savedRating = getRating(currentPhoto.path);
            updateRatingDisplay(savedRating);
            
            // Display uploader info
            const uploaderInfo = document.getElementById('uploaderInfo');
            const uploaderName = document.getElementById('uploaderName');
            if (currentPhoto.uploadedBy) {
                uploaderName.textContent = currentPhoto.uploadedBy;
                uploaderInfo.style.opacity = '1';
            } else {
                uploaderInfo.style.opacity = '0';
            }
            
            // Reload favorites to update current photo highlight
            loadFavorites();
        }
        
        // Rating system with Firebase sync
        async function ratePhoto(rating) {
            if (!currentPhoto || !currentUser) return;
            
            // Save to Firebase if enabled
            if (firebaseEnabled) {
                try {
                    await db.collection('ratings').doc(currentUser).set({
                        [currentPhoto.path]: rating
                    }, { merge: true });
                } catch (error) {
                    console.log('Firebase save failed, using localStorage', error);
                }
            }
            
            // Always save to localStorage as backup
            const ratings = JSON.parse(localStorage.getItem(`toniRatings_${currentUser}`) || '{}');
            ratings[currentPhoto.path] = rating;
            localStorage.setItem(`toniRatings_${currentUser}`, JSON.stringify(ratings));
            
            updateRatingDisplay(rating);
            
            // Reload favorites to show updated rating
            loadFavorites();
        }
        
        async function clearRating() {
            if (!currentPhoto || !currentUser) return;
            
            // Remove from Firebase if enabled
            if (firebaseEnabled) {
                try {
                    const ratingsRef = db.collection('ratings').doc(currentUser);
                    const doc = await ratingsRef.get();
                    
                    if (doc.exists) {
                        const ratings = doc.data();
                        delete ratings[currentPhoto.path];
                        await ratingsRef.set(ratings);
                    }
                } catch (error) {
                    console.log('Firebase delete failed, using localStorage', error);
                }
            }
            
            // Remove from localStorage
            const ratings = JSON.parse(localStorage.getItem(`toniRatings_${currentUser}`) || '{}');
            delete ratings[currentPhoto.path];
            localStorage.setItem(`toniRatings_${currentUser}`, JSON.stringify(ratings));
            
            updateRatingDisplay(0);
            
            // Reload favorites to remove from list
            loadFavorites();
        }
        
        function getRating(photoPath) {
            if (!currentUser) return 0;
            
            const ratings = JSON.parse(localStorage.getItem(`toniRatings_${currentUser}`) || '{}');
            return ratings[photoPath] || 0;
        }
        
        async function loadRatingsFromFirebase() {
            if (!firebaseEnabled || !currentUser) return;
            
            try {
                const doc = await db.collection('ratings').doc(currentUser).get();
                
                if (doc.exists) {
                    const firebaseRatings = doc.data();
                    // Merge with localStorage
                    const localRatings = JSON.parse(localStorage.getItem(`toniRatings_${currentUser}`) || '{}');
                    const mergedRatings = { ...firebaseRatings, ...localRatings };
                    
                    // Save merged ratings
                    localStorage.setItem(`toniRatings_${currentUser}`, JSON.stringify(mergedRatings));
                    
                    // Update Firebase with any local ratings
                    await db.collection('ratings').doc(currentUser).set(mergedRatings);
                    
                    console.log('Ratings synced from Firebase!');
                }
            } catch (error) {
                console.log('Failed to load ratings from Firebase', error);
            }
        }
        
        function updateRatingDisplay(rating) {
            const hearts = document.querySelectorAll('.heart');
            hearts.forEach((heart, index) => {
                if (index < rating) {
                    heart.classList.remove('empty');
                    heart.classList.add('filled');
                } else {
                    heart.classList.remove('filled');
                    heart.classList.add('empty');
                }
            });
        }
        
        // Download photo
        function downloadPhoto() {
            if (!currentPhoto) return;
            
            const link = document.createElement('a');
            link.href = currentPhoto.path;
            link.download = currentPhoto.path.split('/').pop();
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }
        
        // Collage Generator Functions
        function openCollageGenerator() {
            if (catPhotos.length === 0) {
                alert('No photos available to create a collage!');
                return;
            }
            
            document.getElementById('collageModal').classList.remove('hidden');
            generateCollage();
        }
        
        function closeCollageGenerator() {
            document.getElementById('collageModal').classList.add('hidden');
        }
        
        async function generateCollage() {
            const layout = document.getElementById('collageLayout').value;
            const canvas = document.getElementById('collageCanvas');
            const ctx = canvas.getContext('2d');
            
            let gridSize, photoCount;
            
            // Determine grid size based on layout
            if (layout === '2x2') {
                gridSize = 2;
                photoCount = 4;
            } else if (layout === '3x3') {
                gridSize = 3;
                photoCount = 9;
            } else if (layout === '4x4') {
                gridSize = 4;
                photoCount = 16;
            } else if (layout === 'mosaic') {
                gridSize = 3;
                photoCount = 9;
            }
            
            // Canvas size
            const cellSize = 400;
            const padding = 10;
            const canvasSize = (cellSize * gridSize) + (padding * (gridSize + 1));
            
            canvas.width = canvasSize;
            canvas.height = canvasSize;
            
            // White background
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, canvasSize, canvasSize);
            
            // Get random photos
            const selectedPhotos = getRandomPhotosForCollage(photoCount);
            
            // Load and draw images
            const imagePromises = selectedPhotos.map((photoUrl, index) => {
                return new Promise((resolve) => {
                    const img = new Image();
                    img.crossOrigin = 'anonymous';
                    img.onload = () => {
                        if (layout === 'mosaic') {
                            // Random mosaic layout
                            drawMosaicImage(ctx, img, index, gridSize, cellSize, padding);
                        } else {
                            // Regular grid layout
                            const row = Math.floor(index / gridSize);
                            const col = index % gridSize;
                            const x = padding + (col * (cellSize + padding));
                            const y = padding + (row * (cellSize + padding));
                            
                            drawImageCover(ctx, img, x, y, cellSize, cellSize);
                        }
                        resolve();
                    };
                    img.onerror = () => {
                        console.error('Failed to load image:', photoUrl);
                        resolve();
                    };
                    img.src = photoUrl;
                });
            });
            
            await Promise.all(imagePromises);
        }
        
        function getRandomPhotosForCollage(count) {
            const shuffled = [...catPhotos].sort(() => Math.random() - 0.5);
            return shuffled.slice(0, Math.min(count, catPhotos.length)).map(p => p.path);
        }
        
        function drawImageCover(ctx, img, x, y, width, height) {
            // Calculate scaling to cover the area while maintaining aspect ratio
            const imgAspect = img.width / img.height;
            const areaAspect = width / height;
            
            let drawWidth, drawHeight, offsetX, offsetY;
            
            if (imgAspect > areaAspect) {
                // Image is wider - fit to height
                drawHeight = height;
                drawWidth = img.width * (height / img.height);
                offsetX = (width - drawWidth) / 2;
                offsetY = 0;
            } else {
                // Image is taller - fit to width
                drawWidth = width;
                drawHeight = img.height * (width / img.width);
                offsetX = 0;
                offsetY = (height - drawHeight) / 2;
            }
            
            ctx.save();
            ctx.beginPath();
            ctx.rect(x, y, width, height);
            ctx.clip();
            ctx.drawImage(img, x + offsetX, y + offsetY, drawWidth, drawHeight);
            ctx.restore();
        }
        
        function drawMosaicImage(ctx, img, index, gridSize, cellSize, padding) {
            // Randomize size and position for mosaic effect
            const baseRow = Math.floor(index / gridSize);
            const baseCol = index % gridSize;
            
            // Add some randomness to position and size
            const randomOffset = () => (Math.random() - 0.5) * 50;
            const randomSize = () => cellSize + (Math.random() - 0.5) * 100;
            
            const size = Math.max(200, randomSize());
            const x = padding + (baseCol * (cellSize + padding)) + randomOffset();
            const y = padding + (baseRow * (cellSize + padding)) + randomOffset();
            
            drawImageCover(ctx, img, x, y, size, size);
        }
        
        function downloadCollage() {
            const canvas = document.getElementById('collageCanvas');
            const link = document.createElement('a');
            const timestamp = new Date().toISOString().split('T')[0];
            link.download = `toni-collage-${timestamp}.png`;
            link.href = canvas.toDataURL('image/png');
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }
        
        // Sound control
        function initializeMeowSound() {
            // Create a simple beep sound using Web Audio API for the meow
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            
            window.playMeowSound = function() {
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.frequency.value = 800;
                oscillator.type = 'sine';
                
                gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
                
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.2);
            };
        }
        
        function playMeow() {
            try {
                if (window.playMeowSound) {
                    window.playMeowSound();
                }
            } catch (e) {
                console.log('Sound play failed:', e);
            }
        }
        
        function playPurr() {
            try {
                if (soundEnabled) {
                    // Use the real purring MP3 file
                    window.currentPurrAudio = new Audio('feedthestraycats-real-cat-purring-sound-354510.mp3');
                    window.currentPurrAudio.volume = 0.2; // Softer volume (was 0.4)
                    window.currentPurrAudio.play().catch(e => console.log('Purr play failed:', e));
                }
            } catch (e) {
                console.log('Purr play failed:', e);
            }
        }
        
        function stopPurr() {
            try {
                if (window.currentPurrAudio) {
                    window.currentPurrAudio.pause();
                    window.currentPurrAudio.currentTime = 0;
                    window.currentPurrAudio = null;
                }
            } catch (e) {
                console.log('Stop purr failed:', e);
            }
        }
        
        function toggleSound() {
            soundEnabled = document.getElementById('soundToggle').checked;
        }
        
        // Purr Feature - Hidden Easter Egg!
        function initializePurrFeature() {
            const photoContainer = document.getElementById('photoContainer');
            let isMouseOver = false;
            
            // Mouse enter
            photoContainer.addEventListener('mouseenter', function() {
                isMouseOver = true;
            });
            
            // Mouse leave - reset and stop purr
            photoContainer.addEventListener('mouseleave', function() {
                isMouseOver = false;
                purrProgress = 0;
                if (isPurring) {
                    stopPurr(); // Stop purr when mouse leaves
                    isPurring = false;
                }
            });
            
            // Track mouse movement (petting)
            photoContainer.addEventListener('mousemove', function(e) {
                if (!isMouseOver || isPurring) return;
                
                const now = Date.now();
                const timeSinceLastMove = (now - lastMouseMove) / 1000;
                
                // Only count movement if it's continuous (within 100ms)
                if (timeSinceLastMove < 0.1) {
                    purrProgress += 0.016; // Approximately 60fps
                    
                    // Trigger purr when threshold reached
                    if (purrProgress >= purrThreshold && !isPurring) {
                        triggerPurr();
                    }
                } else {
                    // Reset if movement stops and stop purr
                    purrProgress = Math.max(0, purrProgress - 0.05);
                    if (purrProgress === 0 && isPurring) {
                        stopPurr();
                        isPurring = false;
                    }
                }
                
                lastMouseMove = now;
            });
            
            // Also trigger on long press for mobile
            let touchStartTime = 0;
            photoContainer.addEventListener('touchstart', function(e) {
                touchStartTime = Date.now();
            });
            
            photoContainer.addEventListener('touchend', function(e) {
                const touchDuration = (Date.now() - touchStartTime) / 1000;
                
                if (touchDuration >= 2 && !isPurring) {
                    triggerPurr();
                } else if (isPurring) {
                    stopPurr();
                    isPurring = false;
                }
            });
        }
        
        function triggerPurr() {
            isPurring = true;
            
            // Play purr sound
            playPurr();
            
            // Auto-stop after 10 seconds (in case user keeps petting)
            setTimeout(() => {
                if (isPurring) {
                    stopPurr();
                    isPurring = false;
                    purrProgress = 0;
                }
            }, 10000);
        }
        
        // Slideshow control with countdown
        function toggleSlideshow() {
            const isEnabled = document.getElementById('slideshowToggle').checked;
            
            if (isEnabled) {
                startSlideshow();
            } else {
                stopSlideshow();
            }
        }
        
        function startSlideshow() {
            stopSlideshow(); // Clear any existing interval
            
            slideshowTimeLeft = 5;
            updateSlideshowStatus();
            
            // Main slideshow interval (load photo every 5s)
            slideshowInterval = setInterval(() => {
                loadRandomPhoto();
                slideshowTimeLeft = 5;
            }, 5000);
            
            // Countdown interval (update every second)
            slideshowCountdown = setInterval(() => {
                slideshowTimeLeft--;
                updateSlideshowStatus();
                
                if (slideshowTimeLeft <= 0) {
                    slideshowTimeLeft = 5;
                }
            }, 1000);
        }
        
        function stopSlideshow() {
            if (slideshowInterval) {
                clearInterval(slideshowInterval);
                slideshowInterval = null;
            }
            
            if (slideshowCountdown) {
                clearInterval(slideshowCountdown);
                slideshowCountdown = null;
            }
            
            const statusElement = document.getElementById('slideshowStatus');
            statusElement.textContent = '';
            statusElement.classList.remove('countdown');
        }
        
        function updateSlideshowStatus() {
            const statusElement = document.getElementById('slideshowStatus');
            statusElement.classList.add('countdown');
            statusElement.textContent = `Next photo in ${slideshowTimeLeft}s...`;
        }
        
        // Keyboard shortcuts
        document.addEventListener('keydown', function(e) {
            if (e.key === ' ' || e.key === 'ArrowRight') {
                e.preventDefault();
                loadRandomPhoto();
            } else if (e.key === 'ArrowDown') {
                e.preventDefault();
                downloadPhoto();
            } else if (e.key >= '1' && e.key <= '5') {
                ratePhoto(parseInt(e.key));
            }
        });
        
        // Favorites Section with image validation
        async function loadFavorites() {
            if (!currentUser) return;
            
            const ratings = JSON.parse(localStorage.getItem(`toniRatings_${currentUser}`) || '{}');
            const favoritesGrid = document.getElementById('favoritesGrid');
            
            // Get all rated photos
            const ratedPhotos = Object.entries(ratings)
                .map(([path, rating]) => ({ path, rating }))
                .filter(photo => {
                    if (currentFavoriteFilter === 'all') return photo.rating > 0;
                    if (currentFavoriteFilter === 5) return photo.rating === 5;
                    if (currentFavoriteFilter === 4) return photo.rating >= 4;
                    return photo.rating > 0;
                })
                .sort((a, b) => b.rating - a.rating); // Sort by rating, highest first
            
            if (ratedPhotos.length === 0) {
                favoritesGrid.innerHTML = `
                    <div class="no-favorites">
                        <div class="no-favorites-icon">üíî</div>
                        <p>No rated photos yet! Start rating some photos to see them here.</p>
                    </div>
                `;
                return;
            }
            
            // Validate images before displaying
            const validatedPhotos = await Promise.all(
                ratedPhotos.map(async photo => {
                    const exists = await checkImageExists(photo.path);
                    return exists ? photo : null;
                })
            );
            
            // Filter out broken images
            const validPhotos = validatedPhotos.filter(p => p !== null);
            
            // Clean up ratings for broken images
            const brokenCount = ratedPhotos.length - validPhotos.length;
            if (brokenCount > 0) {
                console.log(`Removed ${brokenCount} broken image(s) from favorites`);
                const cleanedRatings = {};
                validPhotos.forEach(photo => {
                    cleanedRatings[photo.path] = photo.rating;
                });
                localStorage.setItem(`toniRatings_${currentUser}`, JSON.stringify(cleanedRatings));
            }
            
            if (validPhotos.length === 0) {
                favoritesGrid.innerHTML = `
                    <div class="no-favorites">
                        <div class="no-favorites-icon">üíî</div>
                        <p>No valid photos found. Images may have been deleted.</p>
                    </div>
                `;
                return;
            }
            
            favoritesGrid.innerHTML = validPhotos.map(photo => {
                const hearts = '‚ô•'.repeat(photo.rating);
                const escapedPath = photo.path.replace(/'/g, "\\'");
                return `
                    <div class="favorite-item">
                        <img 
                            src="${photo.path}" 
                            alt="Favorite cat photo" 
                            onclick="viewFavoritePhoto('${escapedPath}')"
                            onerror="handleBrokenImage(this, '${escapedPath}')"
                        >
                        <div class="favorite-rating">${hearts}</div>
                        <div class="favorite-actions">
                            <button class="success" onclick="downloadFavorite('${escapedPath}')">üíæ</button>
                            <button onclick="viewFavoritePhoto('${escapedPath}')">üëÅÔ∏è View</button>
                            <button class="edit-btn" onclick="editPhotoTags('${escapedPath}')">‚úèÔ∏è Edit</button>
                        </div>
                    </div>
                `;
            }).join('');
        }
        
        // Check if image exists and loads successfully
        function checkImageExists(url) {
            return new Promise((resolve) => {
                const img = new Image();
                img.onload = () => resolve(true);
                img.onerror = () => resolve(false);
                img.src = url;
                
                // Timeout after 5 seconds
                setTimeout(() => resolve(false), 5000);
            });
        }
        
        // Handle broken images in favorites
        function handleBrokenImage(imgElement, path) {
            // Remove from favorites
            if (currentUser) {
                const ratings = JSON.parse(localStorage.getItem(`toniRatings_${currentUser}`) || '{}');
                delete ratings[path];
                localStorage.setItem(`toniRatings_${currentUser}`, JSON.stringify(ratings));
                
                // Remove from Firebase too
                if (firebaseEnabled) {
                    db.collection('ratings').doc(currentUser).update({
                        [path]: firebase.firestore.FieldValue.delete()
                    }).catch(err => console.log('Firebase delete failed:', err));
                }
            }
            
            // Remove the favorite item from display
            const favoriteItem = imgElement.closest('.favorite-item');
            if (favoriteItem) {
                favoriteItem.remove();
            }
            
            // Reload favorites to update count
            setTimeout(() => loadFavorites(), 500);
        }
        
        function filterFavorites(filter) {
            currentFavoriteFilter = filter;
            
            // Update active button
            document.querySelectorAll('.filter-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
            
            loadFavorites();
        }
        
        function viewFavoritePhoto(path) {
            // Find the photo in catPhotos array
            const photo = catPhotos.find(p => p.path === path);
            if (photo) {
                currentPhoto = photo;
                document.getElementById('catPhoto').src = photo.path;
                const savedRating = getRating(photo.path);
                updateRatingDisplay(savedRating);
                
                // Scroll to top
                window.scrollTo({ top: 0, behavior: 'smooth' });
            }
        }
        
        function downloadFavorite(path) {
            const link = document.createElement('a');
            link.href = path;
            link.download = path.split('/').pop();
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }
        
        function editPhotoTags(photoUrl) {
            // Find the photo in catPhotos array
            const photo = catPhotos.find(p => p.path === photoUrl);
            if (!photo) {
                alert('Photo not found');
                return;
            }
            
            // Create modal for editing tags
            const modal = document.createElement('div');
            modal.className = 'edit-modal';
            modal.innerHTML = `
                <div class="edit-modal-content">
                    <h3>‚úèÔ∏è Edit Photo Tags</h3>
                    <img src="${photoUrl}" class="edit-preview-img" />
                    <div class="mood-tags-label" style="text-align: center; margin: 20px 0; font-weight: 600; color: #667eea;">
                        Current moods: ${photo.moods && photo.moods.length > 0 ? photo.moods.map(m => getMoodEmoji(m)).join(' ') : 'None'}
                    </div>
                    <div class="mood-tags" id="editMoodTags">
                        <div class="mood-tag ${photo.moods && photo.moods.includes('unbridled_rage') ? 'selected' : ''}" data-mood="unbridled_rage">üò§ Unbridled Rage</div>
                        <div class="mood-tag ${photo.moods && photo.moods.includes('lazy_boy') ? 'selected' : ''}" data-mood="lazy_boy">üò¥ Lazy Boy</div>
                        <div class="mood-tag ${photo.moods && photo.moods.includes('sweet_perfect_angel_cat') ? 'selected' : ''}" data-mood="sweet_perfect_angel_cat">üòá Sweet Perfect Angel Cat</div>
                        <div class="mood-tag ${photo.moods && photo.moods.includes('weirdo') ? 'selected' : ''}" data-mood="weirdo">ü§™ Weirdo</div>
                        <div class="mood-tag ${photo.moods && photo.moods.includes('someone_help') ? 'selected' : ''}" data-mood="someone_help">üÜò Someone Help</div>
                    </div>
                    <div style="display: flex; gap: 10px; margin-top: 20px;">
                        <button class="success" style="flex: 1;" onclick="saveEditedTags('${photoUrl}')">üíæ Save Changes</button>
                        <button class="secondary" style="flex: 1;" onclick="closeEditModal()">‚ùå Cancel</button>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
            
            // Add click handlers to mood tags
            modal.querySelectorAll('.mood-tag').forEach(tag => {
                tag.addEventListener('click', function() {
                    this.classList.toggle('selected');
                });
            });
        }
        
        async function saveEditedTags(photoUrl) {
            const photo = catPhotos.find(p => p.path === photoUrl);
            if (!photo) return;
            
            // Get selected moods
            const selectedTags = Array.from(document.querySelectorAll('#editMoodTags .mood-tag.selected'));
            const newMoods = selectedTags.map(tag => tag.getAttribute('data-mood'));
            
            // Update local array
            photo.moods = newMoods;
            
            // Update Firestore if connected (shared collection)
            if (db) {
                try {
                    // Find the document with this path in the shared collection
                    const photosRef = db.collection('photos');
                    const querySnapshot = await photosRef.where('path', '==', photoUrl).get();
                    
                    if (!querySnapshot.empty) {
                        const doc = querySnapshot.docs[0];
                        await doc.ref.update({
                            moods: newMoods,
                            updatedAt: new Date()
                        });
                        console.log('Tags updated in Firestore (shared collection)');
                    }
                } catch (error) {
                    console.error('Error updating Firestore:', error);
                }
            }
            
            closeEditModal();
            alert('‚úÖ Tags updated successfully!');
            
            // Reload favorites to show updated moods
            loadFavorites();
        }
        
        function closeEditModal() {
            const modal = document.querySelector('.edit-modal');
            if (modal) modal.remove();
        }
        
        // Upload Functionality
        function initializeUpload() {
            const uploadArea = document.getElementById('uploadArea');
            const fileInput = document.getElementById('fileInput');
            
            // File input change - handle multiple files
            fileInput.addEventListener('change', function(e) {
                handleBatchFileSelect(Array.from(e.target.files));
            });
            
            // Drag and drop - handle multiple files
            uploadArea.addEventListener('dragover', function(e) {
                e.preventDefault();
                e.stopPropagation();
                uploadArea.classList.add('drag-over');
            });
            
            uploadArea.addEventListener('dragleave', function(e) {
                e.preventDefault();
                e.stopPropagation();
                uploadArea.classList.remove('drag-over');
            });
            
            uploadArea.addEventListener('drop', function(e) {
                e.preventDefault();
                e.stopPropagation();
                uploadArea.classList.remove('drag-over');
                
                const files = Array.from(e.dataTransfer.files);
                if (files.length > 0) {
                    handleBatchFileSelect(files);
                }
            });
        }
        
        async function handleBatchFileSelect(files) {
            if (!files || files.length === 0) return;
            
            const validFiles = [];
            
            // Validate each file
            for (const file of files) {
                // Validate file type
                const validTypes = ['image/jpeg', 'image/jpg', 'image/png'];
                if (!validTypes.includes(file.type)) {
                    alert(`Skipping ${file.name}: Please select JPG, JPEG, or PNG images only`);
                    continue;
                }
                
                // Validate file size (10MB)
                if (file.size > 10 * 1024 * 1024) {
                    alert(`Skipping ${file.name}: File size must be less than 10MB`);
                    continue;
                }
                
                // Check for duplicates
                const isDuplicate = await checkForDuplicate(file);
                if (isDuplicate) {
                    alert(`Skipping ${file.name}: This photo has already been uploaded!`);
                    continue;
                }
                
                validFiles.push(file);
            }
            
            if (validFiles.length === 0) {
                alert('No valid files to upload');
                return;
            }
            
            // Create batch items
            batchFiles = await Promise.all(validFiles.map(async file => {
                const reader = new FileReader();
                const preview = await new Promise((resolve) => {
                    reader.onload = (e) => resolve(e.target.result);
                    reader.readAsDataURL(file);
                });
                
                return {
                    file: file,
                    preview: preview,
                    moods: [],
                    id: Date.now() + Math.random()
                };
            }));
            
            renderBatchPreview();
        }
        
        function renderBatchPreview() {
            const batchPreview = document.getElementById('batchPreview');
            const batchTagSection = document.getElementById('batchTagSection');
            
            if (batchFiles.length === 0) {
                batchPreview.innerHTML = '';
                if (batchTagSection) batchTagSection.classList.add('hidden');
                const uploadAllBtn = document.getElementById('uploadAllBtn');
                if (uploadAllBtn) uploadAllBtn.remove();
                return;
            }
            
            // Show batch tag section
            if (batchTagSection) batchTagSection.classList.remove('hidden');
            
            batchPreview.innerHTML = batchFiles.map(item => `
                <div class="batch-item ${selectedBatchItems.includes(item.id) ? 'selected' : ''}" 
                     data-id="${item.id}" 
                     onclick="toggleBatchItemSelection('${item.id}', event)">
                    <button class="remove-batch-item" onclick="removeBatchItem('${item.id}'); event.stopPropagation();">‚úï</button>
                    <img src="${item.preview}" alt="Preview" />
                    <div class="batch-item-moods" id="moods-${item.id}">
                        ${item.moods.length > 0 ? item.moods.map(m => getMoodEmoji(m)).join(' ') : 'No moods selected'}
                    </div>
                    <div class="batch-item-actions" onclick="event.stopPropagation();">
                        <button class="secondary" onclick="selectMoodsForBatchItem('${item.id}')">üè∑Ô∏è Tag</button>
                    </div>
                </div>
            `).join('');
            
            // Add upload all button if batch items exist
            if (batchFiles.length > 0 && !document.getElementById('uploadAllBtn')) {
                const uploadSection = document.getElementById('uploadSection');
                const uploadAllBtn = document.createElement('button');
                uploadAllBtn.id = 'uploadAllBtn';
                uploadAllBtn.className = 'success';
                uploadAllBtn.style.cssText = 'margin: 20px auto; display: block; padding: 15px 40px; font-size: 1.1em;';
                uploadAllBtn.innerHTML = `‚¨ÜÔ∏è Upload All (${batchFiles.length} photos)`;
                uploadAllBtn.onclick = uploadBatchPhotos;
                
                batchPreview.after(uploadAllBtn);
            } else if (batchFiles.length === 0) {
                const uploadAllBtn = document.getElementById('uploadAllBtn');
                if (uploadAllBtn) uploadAllBtn.remove();
            } else {
                // Update count
                const uploadAllBtn = document.getElementById('uploadAllBtn');
                if (uploadAllBtn) {
                    uploadAllBtn.innerHTML = `‚¨ÜÔ∏è Upload All (${batchFiles.length} photos)`;
                }
            }
        }
        
        function getMoodEmoji(mood) {
            const moodMap = {
                'unbridled_rage': 'üò§',
                'lazy_boy': 'üò¥',
                'sweet_perfect_angel_cat': 'üòá',
                'weirdo': 'ü§™',
                'someone_help': 'üÜò'
            };
            return moodMap[mood] || 'üê±';
        }
        
        function removeBatchItem(id) {
            batchFiles = batchFiles.filter(item => item.id !== parseFloat(id));
            selectedBatchItems = selectedBatchItems.filter(itemId => itemId !== parseFloat(id));
            renderBatchPreview();
            updateSelectedCount();
        }
        
        function toggleBatchItemSelection(id, event) {
            const numId = parseFloat(id);
            const index = selectedBatchItems.indexOf(numId);
            
            // Check if Ctrl/Cmd key is pressed
            const isMultiSelect = event.ctrlKey || event.metaKey;
            
            if (isMultiSelect) {
                // Multi-select mode: toggle this item
                if (index > -1) {
                    selectedBatchItems.splice(index, 1);
                } else {
                    selectedBatchItems.push(numId);
                }
            } else {
                // Single select mode: select only this item
                if (index > -1 && selectedBatchItems.length === 1) {
                    // If this is the only selected item, deselect it
                    selectedBatchItems = [];
                } else {
                    // Select only this item
                    selectedBatchItems = [numId];
                }
            }
            
            renderBatchPreview();
            updateSelectedCount();
        }
        
        function selectAllBatchItems() {
            selectedBatchItems = batchFiles.map(item => item.id);
            renderBatchPreview();
            updateSelectedCount();
        }
        
        function deselectAllBatchItems() {
            selectedBatchItems = [];
            renderBatchPreview();
            updateSelectedCount();
        }
        
        function updateSelectedCount() {
            const countEl = document.getElementById('selectedCount');
            if (countEl) {
                const count = selectedBatchItems.length;
                countEl.textContent = count === 0 ? 'No photos selected' : 
                                     count === 1 ? '1 photo selected' : 
                                     `${count} photos selected`;
                countEl.style.color = count > 0 ? '#667eea' : '#999';
            }
        }
        
        function toggleBatchAllMood(mood) {
            const tag = document.querySelector(`#batchAllMoodTags .mood-tag[data-mood="${mood}"]`);
            if (!tag) return;
            
            if (batchAllMoods.includes(mood)) {
                batchAllMoods = batchAllMoods.filter(m => m !== mood);
                tag.classList.remove('selected');
            } else {
                batchAllMoods.push(mood);
                tag.classList.add('selected');
            }
            
            console.log('Batch all moods:', batchAllMoods);
        }
        
        function applyBatchTagsToSelected() {
            if (batchAllMoods.length === 0) {
                alert('Please select at least one mood tag to apply');
                return;
            }
            
            if (selectedBatchItems.length === 0) {
                alert('Please select photos first (click photos to select them)');
                return;
            }
            
            // Apply selected moods to selected batch files only
            batchFiles.forEach(item => {
                if (selectedBatchItems.includes(item.id)) {
                    // Add moods that aren't already present
                    batchAllMoods.forEach(mood => {
                        if (!item.moods.includes(mood)) {
                            item.moods.push(mood);
                        }
                    });
                }
            });
            
            // Clear batch all moods selection
            batchAllMoods = [];
            document.querySelectorAll('#batchAllMoodTags .mood-tag').forEach(tag => {
                tag.classList.remove('selected');
            });
            
            // Deselect photos after tagging
            selectedBatchItems = [];
            
            // Re-render the preview to show updated tags
            renderBatchPreview();
            updateSelectedCount();
            
            alert(`‚úÖ Tags applied to selected photos!`);
        }
        
        function clearSelectedTags() {
            if (selectedBatchItems.length === 0) {
                alert('Please select photos first (click photos to select them)');
                return;
            }
            
            if (!confirm(`Clear all tags from ${selectedBatchItems.length} selected photo(s)?`)) {
                return;
            }
            
            // Clear moods from selected batch files
            batchFiles.forEach(item => {
                if (selectedBatchItems.includes(item.id)) {
                    item.moods = [];
                }
            });
            
            // Deselect photos after clearing
            selectedBatchItems = [];
            
            // Re-render the preview
            renderBatchPreview();
            updateSelectedCount();
            
            alert('‚úÖ Tags cleared from selected photos!');
        }
        
        function selectMoodsForBatchItem(id) {
            const item = batchFiles.find(i => i.id === parseFloat(id));
            if (!item) return;
            
            // Create modal for mood selection
            const modal = document.createElement('div');
            modal.className = 'edit-modal';
            modal.innerHTML = `
                <div class="edit-modal-content">
                    <h3>Select Moods for ${item.file.name}</h3>
                    <img src="${item.preview}" class="edit-preview-img" />
                    <div class="mood-tags" id="batchMoodTags">
                        <div class="mood-tag ${item.moods.includes('unbridled_rage') ? 'selected' : ''}" data-mood="unbridled_rage">üò§ Unbridled Rage</div>
                        <div class="mood-tag ${item.moods.includes('lazy_boy') ? 'selected' : ''}" data-mood="lazy_boy">üò¥ Lazy Boy</div>
                        <div class="mood-tag ${item.moods.includes('sweet_perfect_angel_cat') ? 'selected' : ''}" data-mood="sweet_perfect_angel_cat">üòá Sweet Perfect Angel Cat</div>
                        <div class="mood-tag ${item.moods.includes('weirdo') ? 'selected' : ''}" data-mood="weirdo">ü§™ Weirdo</div>
                        <div class="mood-tag ${item.moods.includes('someone_help') ? 'selected' : ''}" data-mood="someone_help">üÜò Someone Help</div>
                    </div>
                    <div style="display: flex; gap: 10px; margin-top: 20px;">
                        <button class="success" style="flex: 1;" onclick="saveBatchItemMoods('${id}')">üíæ Save</button>
                        <button class="secondary" style="flex: 1;" onclick="closeBatchMoodModal()">‚ùå Cancel</button>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
            
            // Add click handlers to mood tags
            modal.querySelectorAll('.mood-tag').forEach(tag => {
                tag.addEventListener('click', function() {
                    this.classList.toggle('selected');
                });
            });
        }
        
        function saveBatchItemMoods(id) {
            const item = batchFiles.find(i => i.id === parseFloat(id));
            if (!item) return;
            
            const selectedTags = Array.from(document.querySelectorAll('#batchMoodTags .mood-tag.selected'));
            item.moods = selectedTags.map(tag => tag.getAttribute('data-mood'));
            
            closeBatchMoodModal();
            renderBatchPreview();
        }
        
        function closeBatchMoodModal() {
            const modal = document.querySelector('.edit-modal');
            if (modal) modal.remove();
        }
        
        async function uploadBatchPhotos() {
            if (batchFiles.length === 0) {
                alert('No photos to upload');
                return;
            }
            
            const uploadBtn = document.getElementById('uploadAllBtn');
            if (uploadBtn) uploadBtn.disabled = true;
            
            let successCount = 0;
            let failCount = 0;
            const errors = [];
            
            for (let i = 0; i < batchFiles.length; i++) {
                const item = batchFiles[i];
                
                if (uploadBtn) {
                    uploadBtn.innerHTML = `‚è≥ Uploading ${i + 1}/${batchFiles.length}...`;
                }
                
                try {
                    await uploadSinglePhoto(item.file, item.moods);
                    successCount++;
                } catch (error) {
                    console.error('Upload failed for', item.file.name, ':', error);
                    errors.push(`${item.file.name}: ${error.message}`);
                    failCount++;
                }
            }
            
            batchFiles = [];
            renderBatchPreview();
            
            let message = `Upload complete!\n\n${successCount} photos uploaded successfully`;
            if (failCount > 0) {
                message += `\n${failCount} photos failed`;
                if (errors.length > 0) {
                    message += '\n\nErrors:\n' + errors.slice(0, 3).join('\n');
                    if (errors.length > 3) {
                        message += `\n...and ${errors.length - 3} more. Check console for details.`;
                    }
                }
            }
            alert(message);
            
            // Reload the gallery
            if (successCount > 0) {
                await loadUploadedPhotos();
                loadRandomPhoto();
            }
        }
        
        async function uploadSinglePhoto(file, moods) {
            console.log('Uploading photo:', file.name, 'with moods:', moods);
            console.log('Cloudinary config:', cloudinaryConfig);
            
            const formData = new FormData();
            formData.append('file', file);
            formData.append('upload_preset', cloudinaryConfig.uploadPreset);
            formData.append('folder', cloudinaryConfig.folder);
            
            const response = await fetch(cloudinaryConfig.uploadUrl, {
                method: 'POST',
                body: formData
            });
            
            console.log('Upload response status:', response.status);
            
            if (!response.ok) {
                const errorText = await response.text();
                console.error('Upload failed. Status:', response.status, 'Response:', errorText);
                throw new Error(`Upload failed: ${response.status} - ${errorText}`);
            }
            
            const data = await response.json();
            console.log('Upload successful. URL:', data.secure_url);
            const photoUrl = data.secure_url;
            
            // Generate and save hash
            const hash = await generateFileHash(file);
            savePhotoHash(hash);
            
            // Save to Firestore (shared collection for everyone to see)
            if (db && currentUser) {
                try {
                    await db.collection('photos').add({
                        path: photoUrl,
                        moods: moods,
                        uploadedBy: currentUser,
                        uploadedAt: new Date(),
                        hash: hash
                    });
                    console.log('Saved to Firestore (shared collection)');
                } catch (error) {
                    console.error('Error saving to Firestore:', error);
                }
            }
            
            // Add to local array
            catPhotos.push({ path: photoUrl, moods: moods });
            console.log('Added to catPhotos array');
            
            // Save to localStorage so it persists across page reloads
            const savedPhotos = JSON.parse(localStorage.getItem('uploadedPhotos') || '[]');
            savedPhotos.push({
                path: photoUrl,
                moods: moods,
                hash: hash,
                uploadedBy: currentUser,
                uploadedAt: new Date().toISOString()
            });
            localStorage.setItem('uploadedPhotos', JSON.stringify(savedPhotos));
            console.log('Saved to localStorage');
            
            return photoUrl;
        }
        
        function handleFileSelect(file) {
            if (!file) return;
            
            // Validate file type
            const validTypes = ['image/jpeg', 'image/jpg', 'image/png'];
            if (!validTypes.includes(file.type)) {
                alert('Please select a JPG, JPEG, or PNG image');
                return;
            }
            
            // Validate file size (10MB)
            if (file.size > 10 * 1024 * 1024) {
                alert('File size must be less than 10MB');
                return;
            }
            
            // Check for duplicates
            checkForDuplicate(file).then(isDuplicate => {
                if (isDuplicate) {
                    alert('‚ö†Ô∏è This photo has already been uploaded!\n\nPlease select a different photo.');
                    return;
                }
                
                selectedFile = file;
                selectedMoods = [];
                
                // Show preview
                const reader = new FileReader();
                reader.onload = function(e) {
                    document.getElementById('previewImage').src = e.target.result;
                    document.getElementById('uploadPreview').classList.add('show');
                    
                    // Reset mood tags
                    document.querySelectorAll('.mood-tag').forEach(tag => {
                        tag.classList.remove('selected');
                    });
                };
                reader.readAsDataURL(file);
            });
        }
        
        // Check if photo is a duplicate using file hash
        async function checkForDuplicate(file) {
            try {
                // Generate hash of file content
                const hash = await generateFileHash(file);
                
                // Check against stored hashes
                const uploadedHashes = JSON.parse(localStorage.getItem('uploadedPhotoHashes') || '[]');
                
                if (uploadedHashes.includes(hash)) {
                    console.log('Duplicate detected! Hash:', hash);
                    return true;
                }
                
                return false;
            } catch (error) {
                console.error('Error checking duplicate:', error);
                return false; // Allow upload if check fails
            }
        }
        
        // Generate SHA-256 hash of file
        async function generateFileHash(file) {
            const buffer = await file.arrayBuffer();
            const hashBuffer = await crypto.subtle.digest('SHA-256', buffer);
            const hashArray = Array.from(new Uint8Array(hashBuffer));
            const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
            return hashHex;
        }
        
        // Save photo hash after successful upload
        function savePhotoHash(hash) {
            const uploadedHashes = JSON.parse(localStorage.getItem('uploadedPhotoHashes') || '[]');
            if (!uploadedHashes.includes(hash)) {
                uploadedHashes.push(hash);
                localStorage.setItem('uploadedPhotoHashes', JSON.stringify(uploadedHashes));
            }
        }
        
        function toggleMoodTag(mood) {
            // Get the mood tag in the upload section (not the mood selector buttons)
            const uploadMoodTags = document.querySelectorAll('#moodTags .mood-tag');
            const tag = Array.from(uploadMoodTags).find(t => t.getAttribute('data-mood') === mood);
            
            if (!tag) return;
            
            if (selectedMoods.includes(mood)) {
                selectedMoods = selectedMoods.filter(m => m !== mood);
                tag.classList.remove('selected');
            } else {
                selectedMoods.push(mood);
                tag.classList.add('selected');
            }
            
            console.log('Selected moods:', selectedMoods); // Debug log
        }
        
        async function uploadPhoto() {
            if (!selectedFile) {
                alert('Please select a file first');
                return;
            }
            
            if (selectedMoods.length === 0) {
                alert('Please select at least one mood tag');
                return;
            }
            
            // Check if Cloudinary is configured
            if (cloudinaryConfig.cloudName === 'YOUR_CLOUD_NAME') {
                alert('‚ö†Ô∏è Cloudinary is not configured yet. Please set up your Cloudinary account first.\n\nSee CLOUDINARY_SETUP.md for instructions.');
                return;
            }
            
            try {
                // Generate hash before upload
                const fileHash = await generateFileHash(selectedFile);
                
                // Show progress
                document.getElementById('uploadProgress').classList.add('show');
                document.getElementById('uploadPreview').style.opacity = '0.5';
                document.getElementById('progressFill').textContent = 'Uploading...';
                
                // Create FormData for Cloudinary upload
                const formData = new FormData();
                formData.append('file', selectedFile);
                formData.append('upload_preset', cloudinaryConfig.uploadPreset);
                formData.append('folder', 'toni-gallery');
                
                // Upload to Cloudinary
                const response = await fetch(
                    `https://api.cloudinary.com/v1_1/${cloudinaryConfig.cloudName}/image/upload`,
                    {
                        method: 'POST',
                        body: formData
                    }
                );
                
                if (!response.ok) {
                    throw new Error('Upload failed: ' + response.statusText);
                }
                
                const data = await response.json();
                const photoURL = data.secure_url;
                
                // Save photo hash to prevent future duplicates
                savePhotoHash(fileHash);
                
                // Save photo metadata to Firestore (if available)
                if (firebaseEnabled && db) {
                    try {
                        console.log('Attempting to save to Firestore:', {
                            path: photoURL,
                            moods: selectedMoods,
                            uploadedBy: currentUser
                        });
                        
                        const docRef = await db.collection('photos').add({
                            path: photoURL,
                            cloudinaryId: data.public_id,
                            fileHash: fileHash,
                            moods: selectedMoods,
                            uploadedBy: currentUser,
                            uploadedAt: firebase.firestore.FieldValue.serverTimestamp()
                        });
                        
                        console.log('‚úÖ Photo metadata saved to Firestore successfully! Doc ID:', docRef.id);
                    } catch (firestoreError) {
                        console.error('‚ùå Firestore save FAILED:', firestoreError);
                        console.error('Error code:', firestoreError.code);
                        console.error('Error message:', firestoreError.message);
                        alert('‚ö†Ô∏è Photo uploaded to Cloudinary, but failed to sync to Firestore.\n\nError: ' + firestoreError.message + '\n\nThis means other users may not see this photo. Please check Firestore security rules.');
                    }
                } else {
                    console.warn('‚ö†Ô∏è Firebase not enabled. Photo saved to localStorage only.');
                    if (!firebaseEnabled) console.log('Reason: firebaseEnabled =', firebaseEnabled);
                    if (!db) console.log('Reason: db =', db);
                }
                
                // Add to local catPhotos array
                catPhotos.push({
                    path: photoURL,
                    moods: selectedMoods,
                    hash: fileHash
                });
                
                // Save to localStorage as backup
                const savedPhotos = JSON.parse(localStorage.getItem('uploadedPhotos') || '[]');
                savedPhotos.push({
                    path: photoURL,
                    moods: selectedMoods,
                    hash: fileHash,
                    uploadedBy: currentUser,
                    uploadedAt: new Date().toISOString()
                });
                localStorage.setItem('uploadedPhotos', JSON.stringify(savedPhotos));
                
                document.getElementById('progressFill').textContent = '‚úÖ Complete!';
                document.getElementById('progressFill').style.width = '100%';
                
                setTimeout(() => {
                    alert('‚úÖ Photo uploaded successfully!\n\nYour photo is now live in the gallery!');
                    resetUpload();
                    loadRandomPhoto();
                }, 500);
                
            } catch (error) {
                console.error('Upload error:', error);
                alert('‚ùå Upload failed: ' + error.message + '\n\nPlease check your internet connection and try again.');
                resetUpload();
            }
        }
        
        function cancelUpload() {
            resetUpload();
        }
        
        function resetUpload() {
            selectedFile = null;
            selectedMoods = [];
            batchFiles = [];
            document.getElementById('fileInput').value = '';
            document.getElementById('uploadPreview').classList.remove('show');
            document.getElementById('uploadPreview').style.opacity = '1';
            document.getElementById('uploadProgress').classList.remove('show');
            document.getElementById('progressFill').style.width = '0%';
            document.getElementById('progressFill').textContent = '0%';
            
            // Clear batch preview
            renderBatchPreview();
            
            // Reset mood tags
            document.querySelectorAll('.mood-tag').forEach(tag => {
                tag.classList.remove('selected');
            });
        }
        
        // Load previously uploaded photos from localStorage on startup
        // Load photos from Firestore (shared collection for everyone)
        let firestoreUnsubscribe = null; // Store unsubscribe function
        
        async function loadPhotosFromFirestore() {
            if (!db) {
                console.warn('‚ö†Ô∏è Firestore not available, loading from localStorage only');
                console.log('db =', db, 'firebaseEnabled =', firebaseEnabled);
                loadUploadedPhotos();
                loadRandomPhoto();
                return;
            }
            
            try {
                console.log('üì° Setting up real-time photo sync from Firestore...');
                console.log('Firebase enabled:', firebaseEnabled);
                console.log('Database object:', db);
                
                // Use onSnapshot for real-time updates
                firestoreUnsubscribe = db.collection('photos')
                    .orderBy('uploadedAt', 'desc')
                    .onSnapshot((snapshot) => {
                        console.log('‚úÖ Firestore snapshot received:', snapshot.size, 'photos');
                        
                        if (snapshot.size === 0) {
                            console.log('‚ÑπÔ∏è No photos in Firestore yet. This is normal for first-time setup.');
                        }
                        
                        catPhotos.length = 0; // Clear existing photos
                        
                        snapshot.forEach(doc => {
                            const data = doc.data();
                            console.log('üì∑ Loading photo from Firestore:', {
                                id: doc.id,
                                path: data.path,
                                moods: data.moods,
                                uploadedBy: data.uploadedBy
                            });
                            
                            catPhotos.push({
                                path: data.path,
                                moods: data.moods || [],
                                uploadedBy: data.uploadedBy || 'Unknown',
                                uploadedAt: data.uploadedAt,
                                hash: data.hash || data.fileHash,
                                firestoreId: doc.id
                            });
                        });
                        
                        console.log(`‚úÖ Total photos loaded from Firestore: ${catPhotos.length}`);
                        
                        // Also load from localStorage as backup
                        const localPhotoCount = catPhotos.length;
                        loadUploadedPhotos();
                        console.log(`üì¶ Photos from localStorage: ${catPhotos.length - localPhotoCount}`);
                        
                        // Refresh the display with new photos
                        console.log(`üñºÔ∏è Total photos available: ${catPhotos.length}`);
                        loadRandomPhoto();
                        
                    }, (error) => {
                        console.error('‚ùå Error in Firestore snapshot listener:', error);
                        console.error('Error code:', error.code);
                        console.error('Error message:', error.message);
                        
                        if (error.code === 'permission-denied') {
                            console.error('üö´ PERMISSION DENIED: Firestore security rules are blocking access!');
                            console.error('You need to update Firestore security rules to allow read/write access.');
                        }
                        
                        // Fall back to localStorage if Firestore fails
                        loadUploadedPhotos();
                        loadRandomPhoto();
                    });
                
                console.log('‚úÖ Firestore listener set up successfully!');
                
            } catch (error) {
                console.error('‚ùå Error setting up Firestore listener:', error);
                console.error('Error details:', error);
                // Fall back to localStorage if Firestore fails
                loadUploadedPhotos();
                loadRandomPhoto();
            }
        }
        
        function loadUploadedPhotos() {
            const savedPhotos = JSON.parse(localStorage.getItem('uploadedPhotos') || '[]');
            console.log('üì¶ Loading photos from localStorage backup:', savedPhotos.length, 'photos');
            savedPhotos.forEach(photo => {
                // Check if photo already exists in catPhotos
                if (!catPhotos.find(p => p.path === photo.path)) {
                    catPhotos.push({
                        path: photo.path,
                        moods: photo.moods
                    });
                }
            });
        }
        
        // REMOVED DUPLICATE: Initialize upload on page load is handled by main load event listener
    
    </script>
</body>
</html>
